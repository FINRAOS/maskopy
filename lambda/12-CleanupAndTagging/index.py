"""
Copyright (c) 2019. Maskopy Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.


This lambda cleans up any resources generated by the step function.
This lambda will also tag the final snapshot generated.

This lambda expects the following inputs:
- ApplicationName
- CreatedDestinationSnapshots
- CreatedFinalSnapshots
- CreatedSnapshots
- DestinationEnv
- DestinationRestoredDatabases
- RdsSnapshotIdentifier

Optional:
- ObfuscateRunMode
"""
import json
import os
import time

import boto3
from botocore.exceptions import ClientError

ASSUME_ROLE_ARN = os.environ['assume_role_arn']

def lambda_handler(event, context):
    """Lambda handler for the eleventh lambda of the Maskopy process.
    Args:
        event (dict): AWS Lambda uses this parameter to pass in event data to the handler.
        context (Context): AWS Lambda provides runtime info and meta data.
    Returns:
        :obj:`list` of :obj`dict` of str:str:
            Message to be sent to SQS.
    """
    result = []
    status = ''

    asg_client = boto3.client('autoscaling')
    ecs_client = boto3.client('ecs')
    rds_client = boto3.client('rds')
    sts_client = boto3.client('sts')
    session = create_account_session(
        sts_client, ASSUME_ROLE_ARN, context.aws_request_id)
    rds_source_client = session.client('rds')
    engine=event['CreatedSnapshots'][0]['Engine']
    status_1 = True
    status_2 = True
    status_3 = True
    # status_1 will return the status of deleting the copied snapshot in the source environment.
    # status_2 will return the status of deleting the copied snapshot in the destination
    # environment.
    # status_3 will return the status of deleting the restored database in the destination
    # environment used for obfuscation.
    for shared_snapshot in event['CreatedSnapshots']:
        status_1 = delete_snapshot(rds_source_client, shared_snapshot['SnapshotName'],engine)
    for destination_snapshot in event['CreatedDestinationSnapshots']:
        status_2 = delete_snapshot(rds_client, destination_snapshot['SnapshotName'],engine)
    for database in event['DestinationRestoredDatabases']:
        status_3 = delete_database(rds_client, database,engine)

    # status_4 will return the status of deleting the ASG and launch configuration.
    # status_5 will return the status of deleting the task definition of the task.
    # status_6 will return the status of deleting the ECS/Fargate cluster.
    if event.get('ObfuscateRunMode') == 'none' and event.get('DestinationEnv') == 'dev':
        status_4 = True
        status_5 = True
        status_6 = True
    elif event.get('ObfuscateRunMode') == 'ecs':
        status_4 = delete_asg(asg_client, event['ecs']['AsgName'])
        status_5 = deregister_task_definition(ecs_client, event['ecs']['TaskDefinition'])
        status_6 = delete_cluster(ecs_client,
                                  event['ecs']['ClusterName'], event['ecs']['InstanceId'])
    else:
        status_4 = True
        status_5 = deregister_task_definition(ecs_client, event['fargate']['TaskDefinition'])
        status_6 = True
    # status_7 will return the status of getting the final snapshot ARN.
    # status_8 will return the status of adding tags to the final snapshot.
    final_snapshot_arn = 'N/A'
    for final_snapshot in event['CreatedFinalSnapshots']:
        status_7 = final_snapshot_arn = get_snapshot_arn(rds_client,
                                                         final_snapshot['SnapshotName'],engine)
        status_8 = add_tags_to_snapshot(rds_client, final_snapshot_arn, event['ApplicationName'],
                                        event['CreatedSnapshots'][0]['Tags'])

    if all([status_1, status_2, status_3, status_4,
            status_5, status_6, status_7, status_8]):
        status = "OK"
        result.append({'Success' : True})
    else:
        status = "CRITICAL"
        result.append({'Success' : False})

    # Create msg to be sent to SQS
    msg = (f"MasKopy process for ApplicationName: {event['ApplicationName']} "
           f"for snapshotID: {event['RdsSnapshotIdentifier']}. "
           f"The status is: {status}. Snapshot ARN = {final_snapshot_arn}")
    json_msg = {
        "ApplicationName": event['ApplicationName'],
        "State": status,
        "SDLC": event['DestinationEnv'],
        "Service": "MasKopy",
        "msgDetail": msg
    }
    print("message:", json.dumps(json_msg))
    result.append({'Message' : json.dumps(json_msg)})
    return result

def delete_snapshot(rds_client, snapshot_identifier, engine):
    """Function to delete snapshot.
    Args:
        rds_client (Client): AWS RDS Client object.
        snapshot_identifier (str): RDS snapshot identifer to delete
        engine: The DB engine of the snapshot
    Returns:
        bool: True if snapshot was deleted successfully or does not exist,
            False otherwise.
    Raises:
        MaskopyResourceException: Exception used when trying to access a resource
            that cannot be accessed.
        MaskopyThrottlingException: Exception used to catch throttling from AWS.
            Used to implement a back off strategy.
    """
    if 'aurora' in engine:
        return delete_snapshot_cluster(rds_client,snapshot_identifier)
    else:
        return delete_snapshot_instance(rds_client,snapshot_identifier)
def delete_snapshot_cluster(rds_client, snapshot_identifier):
    """Function to delete snapshot.
    Args:
        rds_client (Client): AWS RDS Client object.
        snapshot_identifier (str): RDS snapshot identifer to delete
    Returns:
        bool: True if snapshot was deleted successfully or does not exist,
            False otherwise.
    Raises:
        MaskopyResourceException: Exception used when trying to access a resource
            that cannot be accessed.
        MaskopyThrottlingException: Exception used to catch throttling from AWS.
            Used to implement a back off strategy.
    """
    try:
        rds_client.delete_db_cluster_snapshot(
            DBClusterSnapshotIdentifier=snapshot_identifier)
        return True
    except ClientError as err:
        # Check if error code is DBClusterSnapshotNotFound. If so, ignore the error.
        if err.response['Error']['Code'] == 'DBClusterSnapshotNotFound':
            print(f'Snapshot, {snapshot_identifier}, already deleted.')
            return True
        # Check if error code is due to SNAPSHOT not being in an available state.
        if err.response['Error']['Code'] == 'InvalidDBClusterSnapshotState':
            print(f"{snapshot_identifier}: RDS cluster snapshot is not in available state.")
            raise MaskopyResourceException(err)
        # Check if error code is due to throttling.
        if err.response['Error']['Code'] == 'Throttling':
            print(f"Throttling occurred when deleting cluster snapshot: {snapshot_identifier}.")
            raise MaskopyThrottlingException(err)
        print(f"Error deleting cluster snapshot, {snapshot_identifier}: {err.response['Error']['Code']}.")
        print(err)
        return False
def delete_snapshot_instance(rds_client, snapshot_identifier):
    """Function to delete snapshot.
    Args:
        rds_client (Client): AWS RDS Client object.
        snapshot_identifier (str): RDS snapshot identifer to delete
    Returns:
        bool: True if snapshot was deleted successfully or does not exist,
            False otherwise.
    Raises:
        MaskopyResourceException: Exception used when trying to access a resource
            that cannot be accessed.
        MaskopyThrottlingException: Exception used to catch throttling from AWS.
            Used to implement a back off strategy.
    """
    try:
        rds_client.delete_db_snapshot(
            DBSnapshotIdentifier=snapshot_identifier)
        return True
    except ClientError as err:
        # Check if error code is DBSnapshotNotFound. If so, ignore the error.
        if err.response['Error']['Code'] == 'DBSnapshotNotFound':
            print(f'Snapshot, {snapshot_identifier}, already deleted.')
            return True
        # Check if error code is due to SNAPSHOT not being in an available state.
        if err.response['Error']['Code'] == 'InvalidDBSnapshotState':
            print(f"{snapshot_identifier}: RDS snapshot is not in available state.")
            raise MaskopyResourceException(err)
        # Check if error code is due to throttling.
        if err.response['Error']['Code'] == 'Throttling':
            print(f"Throttling occurred when deleting snapshot: {snapshot_identifier}.")
            raise MaskopyThrottlingException(err)
        print(f"Error deleting snapshot, {snapshot_identifier}: {err.response['Error']['Code']}.")
        print(err)
        return False
def delete_database(rds_client, db_instance_identifier, engine):
    """Function to delete RDS instance.
    Args:
        rds_client (Client): AWS RDS Client object.
        db_instance_identifier (str): RDS instance to delete
        engine: The DB engine of the snapshot
    Returns:
        bool: True if instance was deleted successfully or does not exist,
            False otherwise.
    Raises:
        MaskopyResourceException: Exception used when trying to access a resource
            that cannot be accessed.
        MaskopyThrottlingException: Exception used to catch throttling from AWS.
            Used to implement a back off strategy.
    """
    if 'aurora' in engine:
        return delete_database_cluster(rds_client, db_instance_identifier)
    else:
        return delete_database_instance(rds_client, db_instance_identifier)
def delete_database_cluster(rds_client, db_instance_identifier):
    """Function to delete RDS instance.
    Args:
        rds_client (Client): AWS RDS Client object.
        db_instance_identifier (str): RDS instance to delete
    Returns:
        bool: True if instance was deleted successfully or does not exist,
            False otherwise.
    Raises:
        MaskopyResourceException: Exception used when trying to access a resource
            that cannot be accessed.
        MaskopyThrottlingException: Exception used to catch throttling from AWS.
            Used to implement a back off strategy.
    """
    try:
        rds_client.delete_db_instance(
            DBInstanceIdentifier=db_instance_identifier['DBIdentifier']['DBInstanceIdentifier'],
            SkipFinalSnapshot=True)
        rds_client.delete_db_cluster(
            DBClusterIdentifier=db_instance_identifier['DBIdentifier']['DBClusterIdentifier'],
            SkipFinalSnapshot=True)
        return True
    except ClientError as err:
        # Check if error code is DBSnapshotNotFound. If so, ignore the error.
        if err.response['Error']['Code'] == 'DBInstanceNotFound':
            print(f'RDS instance, {db_instance_identifier}, already deleted.')
            return True
        # Check if error code is due to RDS already being deleted.
        if (err.response['Error']['Code'] == 'InvalidDBInstanceState' and
                'already being deleted.' in err.response['Error']['Message']):
            print(f"{db_instance_identifier}: RDS instance being deleted.")
            return True
        # Check if error code is due to RDS not being in an available state.
        if err.response['Error']['Code'] == 'InvalidDBInstanceState':
            print(f"{db_instance_identifier}: RDS instance is not in available state.")
            raise MaskopyResourceException(err)
        # Check if error code is due to throttling.
        if err.response['Error']['Code'] == 'Throttling':
            print(f"Throttling occurred when deleting database: {db_instance_identifier}.")
            raise MaskopyThrottlingException(err)
        print(f"Error deleting database, {db_instance_identifier}: {err.response['Error']['Code']}")
        print(err)
        return False
def delete_database_instance(rds_client, db_instance_identifier):
    """Function to delete RDS instance.
    Args:
        rds_client (Client): AWS RDS Client object.
        db_instance_identifier (str): RDS instance to delete
    Returns:
        bool: True if instance was deleted successfully or does not exist,
            False otherwise.
    Raises:
        MaskopyResourceException: Exception used when trying to access a resource
            that cannot be accessed.
        MaskopyThrottlingException: Exception used to catch throttling from AWS.
            Used to implement a back off strategy.
    """
    try:
        rds_client.delete_db_instance(
            DBInstanceIdentifier=db_instance_identifier['DBIdentifier']['DBInstanceIdentifier'],
            SkipFinalSnapshot=True)
        return True
    except ClientError as err:
        # Check if error code is DBSnapshotNotFound. If so, ignore the error.
        if err.response['Error']['Code'] == 'DBInstanceNotFound':
            print(f'RDS instance, {db_instance_identifier}, already deleted.')
            return True
        # Check if error code is due to RDS already being deleted.
        if (err.response['Error']['Code'] == 'InvalidDBInstanceState' and
                'already being deleted.' in err.response['Error']['Message']):
            print(f"{db_instance_identifier}: RDS instance being deleted.")
            return True
        # Check if error code is due to RDS not being in an available state.
        if err.response['Error']['Code'] == 'InvalidDBInstanceState':
            print(f"{db_instance_identifier}: RDS instance is not in available state.")
            raise MaskopyResourceException(err)
        # Check if error code is due to throttling.
        if err.response['Error']['Code'] == 'Throttling':
            print(f"Throttling occurred when deleting database: {db_instance_identifier}.")
            raise MaskopyThrottlingException(err)
        print(f"Error deleting database, {db_instance_identifier}: {err.response['Error']['Code']}")
        print(err)
        return False

def delete_asg(asg_client, asg_name):
    """Function to delete ASG.
    Args:
        asg_client (Client): AWS ASG Client object.
        asg_name (str): ASG and launch configuration name to delete
    Returns:
        bool: True if instance was deleted successfully or does not exist,
            False otherwise.
    Raises:
        MaskopyResourceException: Exception used when trying to access a resource
            that cannot be accessed.
        MaskopyThrottlingException: Exception used to catch throttling from AWS.
            Used to implement a back off strategy.
    """
    try:
        # Check if ASG exists and then delete it
        asg_response = asg_client.describe_auto_scaling_groups(
            AutoScalingGroupNames=[asg_name])
        if asg_response['AutoScalingGroups']:
            print(f'Deleting ASG: {asg_name}')
            asg_client.delete_auto_scaling_group(
                AutoScalingGroupName=asg_name, ForceDelete=True)
            time.sleep(40)

        # Check if launch configuration exists and then delete it
        launch_configuration_response = asg_client.describe_launch_configurations(
            LaunchConfigurationNames=[asg_name])
        if launch_configuration_response['LaunchConfigurations']:
            print(f'Deleting launch configuration: {asg_name}.')
            asg_client.delete_launch_configuration(
                LaunchConfigurationName=asg_name)

        return True
    except ClientError as err:
        # Check if error code is ResourceContention.
        if err.response['Error']['Code'] == 'ResourceContention':
            print(f"ASG or launch configuration has a pending update already: {asg_name}.")
            raise MaskopyResourceException(err)
        # Check if error code is ResourceInUse.
        if err.response['Error']['Code'] == 'ResourceInUse':
            print(f"Launch configuration is still in use: {asg_name}.")
            raise MaskopyResourceException(err)
        # Check if error code is due to throttling.
        if err.response['Error']['Code'] == 'Throttling':
            print(f"Throttling occurred when deleting ASG: {asg_name}.")
            raise MaskopyThrottlingException(err)
        print(f"Error deleting ASG, {asg_name}: {err.response['Error']['Code']}")
        print(err)
        return False

def deregister_task_definition(ecs_client, task_definition):
    """Function to deregister task definition.
    Args:
        ecs_client (Client): AWS ECS Client object.
        task_definition (str): Task definition to delete
    Returns:
        bool: True if task definition was deregistered successfully or does not exist,
            False otherwise.
    Raises:
        MaskopyResourceException: Exception used when trying to access a resource
            that cannot be accessed.
        MaskopyThrottlingException: Exception used to catch throttling from AWS.
            Used to implement a back off strategy.
    """
    try:
        print(f'Deregistering task definition: {task_definition}')
        ecs_client.deregister_task_definition(
            taskDefinition=task_definition)
        return True
    except ClientError as err:
        # Check if error code is ClientException.
        if (err.response['Error']['Code'] == 'ClientException' and
                err.response['Error']['Message'] ==
                'The specified task definition does not exist.'):
            print(f'Task definition revision, {task_definition}, does not exist.')
            return True
        print(f"Error deregistering task definition, {task_definition}: "
              f"{err.response['Error']['Code']}")
        print(err)
        return False

def delete_cluster(ecs_client, cluster_name, instance_identifier=None):
    """Function to delete ECS or fargate cluster.
    Args:
        ecs_client (Client): AWS ECS Client object.
        cluster_name (str): Cluster to delete
        instance_identifier (str, optional): Instance identifier to deregister.
            Classical ECS clusters require EC2 instance to be registered.
            Forcing a deregister of the instance allows the ECS cluster to be
            deleted.
    Returns:
        bool: True if cluster was deleted successfully or does not exist,
            False otherwise.
    Raises:
        MaskopyResourceException: Exception used when trying to access a resource
            that cannot be accessed.
        MaskopyThrottlingException: Exception used to catch throttling from AWS.
            Used to implement a back off strategy.
    """
    try:
        cluster = ecs_client.describe_clusters(
            clusters=[cluster_name])
        if instance_identifier:
            ecs_client.deregister_container_instance(
                cluster=cluster_name,
                containerInstance=instance_identifier,
                force=True)

        print('Deleting ECS Cluster:' + cluster_name)
        ecs_client.delete_cluster(cluster=cluster_name)
        return True
    except ClientError as err:
        # Check if error code is ClusterNotFoundException.
        if err.response['Error']['Code'] == 'ClusterNotFoundException':
            print(f'ECS cluster, {cluster_name}, already deleted.')
            return True
        # Check if error code is ClusterContainsContainerInstancesException.
        if err.response['Error']['Code'] == 'ClusterContainsContainerInstancesException':
            print(f'ECS cluster, {cluster_name}, still contains instances.')
            raise MaskopyResourceException(err)
        # Check if error code is ClusterContainsTasksException.
        if err.response['Error']['Code'] == 'ClusterContainsTasksException':
            print(f'ECS cluster, {cluster_name}, still contains tasks.')
            raise MaskopyResourceException(err)
        # Check if error code is due to throttling.
        if err.response['Error']['Code'] == 'Throttling':
            print(f"Throttling occurred when deleting ECS cluster: {cluster}.")
            raise MaskopyThrottlingException(err)
        print(f"Error deleting ECS, {cluster_name}: {err.response['Error']['Code']}")
        print(err)
        return False

def get_snapshot_arn(rds_client, snapshot_identifier, engine):
    """Function to get the full ARN of a snapshot.
    Args:
        rds_client (Client): AWS RDS Client object.
        snapshot_identifier (str): Snapshot identifier to get full ARN
    Returns:
        str: The full ARN of the snapshot_identifier input,
            False otherwise.
    Raises:
        	        MaskopyThrottlingException: Exception used to catch throttling from AWS.
            Used to implement a back off strategy.
    """
    if 'aurora' in engine:
        return  get_snapshot_arn_cluster(rds_client, snapshot_identifier)
    else:
        return  get_snapshot_arn_instance(rds_client, snapshot_identifier)
def get_snapshot_arn_cluster(rds_client, snapshot_identifier):
    """Function to get the full ARN of a snapshot.
    Args:
        rds_client (Client): AWS RDS Client object.
        snapshot_identifier (str): Snapshot identifier to get full ARN
    Returns:
        str: The full ARN of the snapshot_identifier input,
            False otherwise.
    Raises:
        MaskopyThrottlingException: Exception used to catch throttling from AWS.
            Used to implement a back off strategy.
    """
    try:
        response = rds_client.describe_db_cluster_snapshots(
            DBClusterSnapshotIdentifier=snapshot_identifier)
        return response['DBClusterSnapshots'][0]['DBClusterSnapshotArn']
    except ClientError as err:
        # Check if error code is DBClusterSnapshotNotFound.
        if err.response['Error']['Code'] == 'DBClusterSnapshotNotFound':
            print(f'RDS snapshot, {snapshot_identifier}, not found.')
            return False
        # Check if error code is due to throttling.
        if err.response['Error']['Code'] == 'Throttling':
            print(f"Throttling occurred when getting cluster snapshot ARN: {snapshot_identifier}.")
            raise MaskopyThrottlingException(err)
        print(f"Error getting cluster snapshot, {snapshot_identifier}, ARN: "
              f"{err.response['Error']['Code']}")
        print(err)
        return False
def get_snapshot_arn_instance(rds_client, snapshot_identifier):
    """Function to get the full ARN of a snapshot.
    Args:
        rds_client (Client): AWS RDS Client object.
        snapshot_identifier (str): Snapshot identifier to get full ARN
    Returns:
        str: The full ARN of the snapshot_identifier input,
            False otherwise.
    Raises:
        MaskopyThrottlingException: Exception used to catch throttling from AWS.
            Used to implement a back off strategy.
    """
    try:
        response = rds_client.describe_db_snapshots(
            DBSnapshotIdentifier=snapshot_identifier)
        return response['DBSnapshots'][0]['DBSnapshotArn']
    except ClientError as err:
        # Check if error code is DBSnapshotNotFound.
        if err.response['Error']['Code'] == 'DBSnapshotNotFound':
            print(f'RDS snapshot, {snapshot_identifier}, not found.')
            return False
        # Check if error code is due to throttling.
        if err.response['Error']['Code'] == 'Throttling':
            print(f"Throttling occurred when getting snapshot ARN: {snapshot_identifier}.")
            raise MaskopyThrottlingException(err)
        print(f"Error getting snapshot, {snapshot_identifier}, ARN: "
              f"{err.response['Error']['Code']}")
        print(err)
        return False


def add_tags_to_snapshot(rds_client, snapshot_arn, application_name, tags):
    """Function to set default tags on snapshot.
    Args:
        rds_client (Client): AWS RDS Client object.
        snapshot_arn (str): Snapshot ARN.
        application_name (str): The application name to append to the tags.
        tags (obj:`dict` of str:str): The dict of tags to append to snapshot.
    Returns:
        bool: True if tags were applied to final snapshot successfully, False otherwise.
    Raises:
        MaskopyThrottlingException: Exception used to catch throttling from AWS.
            Used to implement a back off strategy.
    """
    try:
        if tags:
            # Go through list of tags of original source snapshot and remove all tags
            # that begin with 'aws:'
            new_tags = []
            for tag in tags:
                print(f"Checking: {tag['Key']}")
                if tag["Key"] == "ApplicationName":
                    tag["Value"] = application_name
                if "aws:" not in tag["Key"]:
                    new_tags.append(tag)

            print("Final list of tags:")
            print(new_tags)
            response = rds_client.add_tags_to_resource(ResourceName=snapshot_arn, Tags=new_tags)
            print(response)

        return True
    except ClientError as err:
        # Check if error code is DBSnapshotNotFound.
        if err.response['Error']['Code'] == 'DBSnapshotNotFound':
            print(f'RDS snapshot, {snapshot_arn}, not found.')
            return False
        # Check if error code is due to throttling.
        if err.response['Error']['Code'] == 'Throttling':
            print(f"Throttling occurred when applying tags to {snapshot_arn}.")
            raise MaskopyThrottlingException(err)
        print(f"Error applying tags to snapshot, {snapshot_arn}: {err.response['Error']['Code']}")
        print(err)
        return False

def create_account_session(sts_client, role_arn, request_id):
    """Function to create and assume account role.
    Args:
        sts_client (Client): AWS STS Client object.
        role_arn (str): The arn of the role to assume a session.
        request_id (str): UUID for session to uniquely identify session name.
    Returns:
        :obj:`boto3.session.Session`:
            A session of the role to be used.
    """
    sts_response = sts_client.assume_role(
        RoleArn=role_arn,
        RoleSessionName=request_id
    )

    return boto3.session.Session(
        aws_access_key_id=sts_response['Credentials']['AccessKeyId'],
        aws_secret_access_key=sts_response['Credentials']['SecretAccessKey'],
        aws_session_token=sts_response['Credentials']['SessionToken']
    )

class MaskopyResourceException(Exception):
    """Exception raised when IAM role or user is not able to access the
    resource.
    """

class MaskopyThrottlingException(Exception):
    """Exception raised when AWS request returns a Throttling exception.
    """
